# 串行 GC
    串行 GC 对年轻代和老年代都使用单线程的垃圾收集器
    如果堆内存过大，会造成 STW 时间过长，只适用于单核且堆内存使用较小的程序
    
# 并行 GC
    并行 GC 相对于串行 GC 只是充分利用了 CPU 的多核
    由于对年轻代和老年代的垃圾回收都会造成 STW，所以适合的应用堆内存也不应过大
    
# CMS
    CMS 对年轻代使用 ParNewGC，并行的进行垃圾回收
    其在老年代进行垃圾回收时，分为六个阶段，其中耗时的四个阶段是可以和业务线程并发执行的
    该 GC 降低了延时，但同时也降低了业务线程的吞吐量
    适用于对低延迟要求较高的应用程序
    
# G1
    G1 GC 对堆内存进行了分区处理，使用增量的方式清理内存
    因为分区和增量处理的方式，一定程度使得 GC 变得可配置了（比如配置 GC 暂停的最大时间）
    由于对于老年代的垃圾回收更平均的分配，故业务线程的吞吐量进一步降低